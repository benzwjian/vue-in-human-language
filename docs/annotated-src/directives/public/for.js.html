<!DOCTYPE html>
<html>
<head>
    <title>for</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport"
        content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/file_1.css"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/file_5.css"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/32px.png"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/40px.png"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/throbber.gif"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/file_7.css"/>
    
    <link rel="stylesheet"
        media="all"
        href="../../../assets/file_8.css"/>
    

    
    <script src="../../../assets/file_2.js"
        type="text/javascript"></script>
    
    <script src="../../../assets/file_3.js"
        type="text/javascript"></script>
    
    <script src="../../../assets/file_4.js"
        type="text/javascript"></script>
    
    <script src="../../../assets/file_6.js"
        type="text/javascript"></script>
    

    <script type="application/json" id="jsTreeJSON">
        [{"id":"annotated-src/filters/array-filters.js","text":"array-filters.js","icon":"jstree-file","parent":"annotated-src/filters","a_attr":{"href":"../../filters/array-filters.js.html"},"state":{"selected":false}},{"id":"annotated-src","text":"annotated-src","icon":"jstree-folder","parent":"#","a_attr":{"href":"../.."},"state":{"opened":true}},{"id":"annotated-src/cache.js","text":"cache.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../cache.js.html"},"state":{"selected":false}},{"id":"annotated-src/compiler","text":"compiler","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../compiler"},"state":{"opened":false}},{"id":"annotated-src/compiler/compile-props.js","text":"compile-props.js","icon":"jstree-file","parent":"annotated-src/compiler","a_attr":{"href":"../../compiler/compile-props.js.html"},"state":{"selected":false}},{"id":"annotated-src/compiler/compile.js","text":"compile.js","icon":"jstree-file","parent":"annotated-src/compiler","a_attr":{"href":"../../compiler/compile.js.html"},"state":{"selected":false}},{"id":"annotated-src/compiler/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/compiler","a_attr":{"href":"../../compiler/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/compiler/resolve-slots.js","text":"resolve-slots.js","icon":"jstree-file","parent":"annotated-src/compiler","a_attr":{"href":"../../compiler/resolve-slots.js.html"},"state":{"selected":false}},{"id":"annotated-src/compiler/transclude.js","text":"transclude.js","icon":"jstree-file","parent":"annotated-src/compiler","a_attr":{"href":"../../compiler/transclude.js.html"},"state":{"selected":false}},{"id":"annotated-src/config.js","text":"config.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../config.js.html"},"state":{"selected":false}},{"id":"annotated-src/directive.js","text":"directive.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../directive.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives","text":"directives","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":".."},"state":{"opened":true}},{"id":"annotated-src/directives/element","text":"element","icon":"jstree-folder","parent":"annotated-src/directives","a_attr":{"href":"../element"},"state":{"opened":false}},{"id":"annotated-src/directives/element/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/directives/element","a_attr":{"href":"../element/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/element/partial.js","text":"partial.js","icon":"jstree-file","parent":"annotated-src/directives/element","a_attr":{"href":"../element/partial.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/element/slot.js","text":"slot.js","icon":"jstree-file","parent":"annotated-src/directives/element","a_attr":{"href":"../element/slot.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal","text":"internal","icon":"jstree-folder","parent":"annotated-src/directives","a_attr":{"href":"../internal"},"state":{"opened":false}},{"id":"annotated-src/directives/internal/class.js","text":"class.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/class.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal/component.js","text":"component.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/component.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal/prop.js","text":"prop.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/prop.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal/style.js","text":"style.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/style.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/internal/transition.js","text":"transition.js","icon":"jstree-file","parent":"annotated-src/directives/internal","a_attr":{"href":"../internal/transition.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/priorities.js","text":"priorities.js","icon":"jstree-file","parent":"annotated-src/directives","a_attr":{"href":"../priorities.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public","text":"public","icon":"jstree-folder","parent":"annotated-src/directives","a_attr":{"href":"."},"state":{"opened":true}},{"id":"annotated-src/directives/public/bind.js","text":"bind.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"bind.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/cloak.js","text":"cloak.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"cloak.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/el.js","text":"el.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"el.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/for.js","text":"for.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"for.js.html"},"state":{"selected":true}},{"id":"annotated-src/directives/public/html.js","text":"html.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"html.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/if.js","text":"if.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"if.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"index.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/model","text":"model","icon":"jstree-folder","parent":"annotated-src/directives/public","a_attr":{"href":"model"},"state":{"opened":false}},{"id":"annotated-src/directives/public/model/checkbox.js","text":"checkbox.js","icon":"jstree-file","parent":"annotated-src/directives/public/model","a_attr":{"href":"model/checkbox.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/model/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/directives/public/model","a_attr":{"href":"model/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/model/radio.js","text":"radio.js","icon":"jstree-file","parent":"annotated-src/directives/public/model","a_attr":{"href":"model/radio.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/model/select.js","text":"select.js","icon":"jstree-file","parent":"annotated-src/directives/public/model","a_attr":{"href":"model/select.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/model/text.js","text":"text.js","icon":"jstree-file","parent":"annotated-src/directives/public/model","a_attr":{"href":"model/text.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/on.js","text":"on.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"on.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/ref.js","text":"ref.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"ref.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/show.js","text":"show.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"show.js.html"},"state":{"selected":false}},{"id":"annotated-src/directives/public/text.js","text":"text.js","icon":"jstree-file","parent":"annotated-src/directives/public","a_attr":{"href":"text.js.html"},"state":{"selected":false}},{"id":"annotated-src/filters","text":"filters","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../filters"},"state":{"opened":false}},{"id":"annotated-src/batcher.js","text":"batcher.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../batcher.js.html"},"state":{"selected":false}},{"id":"annotated-src/filters/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/filters","a_attr":{"href":"../../filters/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/fragment","text":"fragment","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../fragment"},"state":{"opened":false}},{"id":"annotated-src/fragment/factory.js","text":"factory.js","icon":"jstree-file","parent":"annotated-src/fragment","a_attr":{"href":"../../fragment/factory.js.html"},"state":{"selected":false}},{"id":"annotated-src/fragment/fragment.js","text":"fragment.js","icon":"jstree-file","parent":"annotated-src/fragment","a_attr":{"href":"../../fragment/fragment.js.html"},"state":{"selected":false}},{"id":"annotated-src/global-api.js","text":"global-api.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../global-api.js.html"},"state":{"selected":false}},{"id":"annotated-src/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../index.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance","text":"instance","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../instance"},"state":{"opened":false}},{"id":"annotated-src/instance/api","text":"api","icon":"jstree-folder","parent":"annotated-src/instance","a_attr":{"href":"../../instance/api"},"state":{"opened":false}},{"id":"annotated-src/instance/api/data.js","text":"data.js","icon":"jstree-file","parent":"annotated-src/instance/api","a_attr":{"href":"../../instance/api/data.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/api/dom.js","text":"dom.js","icon":"jstree-file","parent":"annotated-src/instance/api","a_attr":{"href":"../../instance/api/dom.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/api/events.js","text":"events.js","icon":"jstree-file","parent":"annotated-src/instance/api","a_attr":{"href":"../../instance/api/events.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/api/lifecycle.js","text":"lifecycle.js","icon":"jstree-file","parent":"annotated-src/instance/api","a_attr":{"href":"../../instance/api/lifecycle.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/internal","text":"internal","icon":"jstree-folder","parent":"annotated-src/instance","a_attr":{"href":"../../instance/internal"},"state":{"opened":false}},{"id":"annotated-src/instance/internal/events.js","text":"events.js","icon":"jstree-file","parent":"annotated-src/instance/internal","a_attr":{"href":"../../instance/internal/events.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/internal/init.js","text":"init.js","icon":"jstree-file","parent":"annotated-src/instance/internal","a_attr":{"href":"../../instance/internal/init.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/internal/lifecycle.js","text":"lifecycle.js","icon":"jstree-file","parent":"annotated-src/instance/internal","a_attr":{"href":"../../instance/internal/lifecycle.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/internal/misc.js","text":"misc.js","icon":"jstree-file","parent":"annotated-src/instance/internal","a_attr":{"href":"../../instance/internal/misc.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/internal/state.js","text":"state.js","icon":"jstree-file","parent":"annotated-src/instance/internal","a_attr":{"href":"../../instance/internal/state.js.html"},"state":{"selected":false}},{"id":"annotated-src/instance/vue.js","text":"vue.js","icon":"jstree-file","parent":"annotated-src/instance","a_attr":{"href":"../../instance/vue.js.html"},"state":{"selected":false}},{"id":"annotated-src/observer","text":"observer","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../observer"},"state":{"opened":false}},{"id":"annotated-src/observer/array.js","text":"array.js","icon":"jstree-file","parent":"annotated-src/observer","a_attr":{"href":"../../observer/array.js.html"},"state":{"selected":false}},{"id":"annotated-src/observer/dep.js","text":"dep.js","icon":"jstree-file","parent":"annotated-src/observer","a_attr":{"href":"../../observer/dep.js.html"},"state":{"selected":false}},{"id":"annotated-src/observer/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/observer","a_attr":{"href":"../../observer/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/parsers","text":"parsers","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../parsers"},"state":{"opened":false}},{"id":"annotated-src/parsers/directive.js","text":"directive.js","icon":"jstree-file","parent":"annotated-src/parsers","a_attr":{"href":"../../parsers/directive.js.html"},"state":{"selected":false}},{"id":"annotated-src/parsers/expression.js","text":"expression.js","icon":"jstree-file","parent":"annotated-src/parsers","a_attr":{"href":"../../parsers/expression.js.html"},"state":{"selected":false}},{"id":"annotated-src/parsers/path.js","text":"path.js","icon":"jstree-file","parent":"annotated-src/parsers","a_attr":{"href":"../../parsers/path.js.html"},"state":{"selected":false}},{"id":"annotated-src/parsers/template.js","text":"template.js","icon":"jstree-file","parent":"annotated-src/parsers","a_attr":{"href":"../../parsers/template.js.html"},"state":{"selected":false}},{"id":"annotated-src/parsers/text.js","text":"text.js","icon":"jstree-file","parent":"annotated-src/parsers","a_attr":{"href":"../../parsers/text.js.html"},"state":{"selected":false}},{"id":"annotated-src/transition","text":"transition","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../transition"},"state":{"opened":false}},{"id":"annotated-src/transition/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/transition","a_attr":{"href":"../../transition/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/transition/queue.js","text":"queue.js","icon":"jstree-file","parent":"annotated-src/transition","a_attr":{"href":"../../transition/queue.js.html"},"state":{"selected":false}},{"id":"annotated-src/transition/transition.js","text":"transition.js","icon":"jstree-file","parent":"annotated-src/transition","a_attr":{"href":"../../transition/transition.js.html"},"state":{"selected":false}},{"id":"annotated-src/util","text":"util","icon":"jstree-folder","parent":"annotated-src","a_attr":{"href":"../../util"},"state":{"opened":false}},{"id":"annotated-src/util/component.js","text":"component.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/component.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/debug.js","text":"debug.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/debug.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/dom.js","text":"dom.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/dom.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/env.js","text":"env.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/env.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/index.js","text":"index.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/index.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/lang.js","text":"lang.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/lang.js.html"},"state":{"selected":false}},{"id":"annotated-src/util/options.js","text":"options.js","icon":"jstree-file","parent":"annotated-src/util","a_attr":{"href":"../../util/options.js.html"},"state":{"selected":false}},{"id":"annotated-src/watcher.js","text":"watcher.js","icon":"jstree-file","parent":"annotated-src","a_attr":{"href":"../../watcher.js.html"},"state":{"selected":false}}]
    </script>
</head>
<body class="markdown-body">
<h1>
    for
</h1>
<div class="subHeading">
    annotated-src/directives/public/for.js
</div>
<button type="button" class="navigatorToggle">&#9776; files...</button>
<nav class="navigationTree minimized">
    <input type="text" id="jsTreeSearch" placeholder="search..."/>
    <div></div>
</nav>
<section>
    <ul class="sectionDetails codeOnly">
        
        
        <li id="section-1">
            <div class="annotation">
                
            </div><div class="content">
                <div class="highlight"><pre><span class="hljs-keyword">import</span> FragmentFactory <span class="hljs-keyword">from</span> <span class="hljs-string">'../../fragment/factory'</span>
<span class="hljs-keyword">import</span> { FOR } <span class="hljs-keyword">from</span> <span class="hljs-string">'../priorities'</span>
<span class="hljs-keyword">import</span> { withoutConversion } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../observer/index'</span>
<span class="hljs-keyword">import</span> { getPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../parsers/path'</span>
<span class="hljs-keyword">import</span> {
  isObject,
  warn,
  createAnchor,
  replace,
  before,
  after,
  remove,
  hasOwn,
  inDoc,
  defineReactive,
  def,
  cancellable,
  isArray,
  isPlainObject,
  findVmFromFrag
} <span class="hljs-keyword">from</span> <span class="hljs-string">'../../util/index'</span>

<span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>

<span class="hljs-keyword">const</span> vFor = {

  priority: FOR,
  terminal: <span class="hljs-literal">true</span>,

  params: [
    <span class="hljs-string">'track-by'</span>,
    <span class="hljs-string">'stagger'</span>,
    <span class="hljs-string">'enter-stagger'</span>,
    <span class="hljs-string">'leave-stagger'</span>
  ],

  bind () {
    <span class="hljs-comment">/* support "item in/of items" syntax */</span>
    <span class="hljs-keyword">var</span> inMatch = <span class="hljs-keyword">this</span>.expression.match(<span class="hljs-regexp">/(.*) (?:in|of) (.*)/</span>)
    <span class="hljs-keyword">if</span> (inMatch) {
      <span class="hljs-keyword">var</span> itMatch = inMatch[<span class="hljs-number">1</span>].match(<span class="hljs-regexp">/\((.*),(.*)\)/</span>)
      <span class="hljs-keyword">if</span> (itMatch) {
        <span class="hljs-keyword">this</span>.iterator = itMatch[<span class="hljs-number">1</span>].trim()
        <span class="hljs-keyword">this</span>.alias = itMatch[<span class="hljs-number">2</span>].trim()
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.alias = inMatch[<span class="hljs-number">1</span>].trim()
      }
      <span class="hljs-keyword">this</span>.expression = inMatch[<span class="hljs-number">2</span>]
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.alias) {
      process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; warn(
        <span class="hljs-string">'Invalid v-for expression "'</span> + <span class="hljs-keyword">this</span>.descriptor.raw + <span class="hljs-string">'": '</span> +
        <span class="hljs-string">'alias is required.'</span>,
        <span class="hljs-keyword">this</span>.vm
      )
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">/* uid as a cache identifier */</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-string">'__v-for__'</span> + (++uid)

    <span class="hljs-comment">/* check if this is an option list, */</span>
    <span class="hljs-comment">/* so that we know if we need to update the &lt;select&gt;'s */</span>
    <span class="hljs-comment">/* v-model when the option list has changed. */</span>
    <span class="hljs-comment">/* because v-model has a lower priority than v-for, */</span>
    <span class="hljs-comment">/* the v-model is not bound here yet, so we have to */</span>
    <span class="hljs-comment">/* retrive it in the actual updateModel() function. */</span>
    <span class="hljs-keyword">var</span> tag = <span class="hljs-keyword">this</span>.el.tagName
    <span class="hljs-keyword">this</span>.isOption =
      (tag === <span class="hljs-string">'OPTION'</span> || tag === <span class="hljs-string">'OPTGROUP'</span>) &amp;&amp;
      <span class="hljs-keyword">this</span>.el.parentNode.tagName === <span class="hljs-string">'SELECT'</span>

    <span class="hljs-comment">/* setup anchor nodes */</span>
    <span class="hljs-keyword">this</span>.start = createAnchor(<span class="hljs-string">'v-for-start'</span>)
    <span class="hljs-keyword">this</span>.end = createAnchor(<span class="hljs-string">'v-for-end'</span>)
    replace(<span class="hljs-keyword">this</span>.el, <span class="hljs-keyword">this</span>.end)
    before(<span class="hljs-keyword">this</span>.start, <span class="hljs-keyword">this</span>.end)

    <span class="hljs-comment">/* cache */</span>
    <span class="hljs-keyword">this</span>.cache = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)

    <span class="hljs-comment">/* fragment factory */</span>
    <span class="hljs-keyword">this</span>.factory = <span class="hljs-keyword">new</span> FragmentFactory(<span class="hljs-keyword">this</span>.vm, <span class="hljs-keyword">this</span>.el)
  },

  update (data) {
    <span class="hljs-keyword">this</span>.diff(data)
    <span class="hljs-keyword">this</span>.updateRef()
    <span class="hljs-keyword">this</span>.updateModel()
  },

  <span class="hljs-comment">/**
   * Diff, based on new data and old data, determine the
   * minimum amount of DOM manipulations needed to make the
   * DOM reflect the new data Array.
   *
   * The algorithm diffs the new data Array by storing a
   * hidden reference to an owner vm instance on previously
   * seen data. This allows us to achieve O(n) which is
   * better than a levenshtein distance based algorithm,
   * which is O(m * n).
   *
   * @param {Array} data
   */</span>

  diff (data) {
    <span class="hljs-comment">/* check if the Array was converted from an Object */</span>
    <span class="hljs-keyword">var</span> item = data[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">var</span> convertedFromObject = <span class="hljs-keyword">this</span>.fromObject =
      isObject(item) &amp;&amp;
      hasOwn(item, <span class="hljs-string">'$key'</span>) &amp;&amp;
      hasOwn(item, <span class="hljs-string">'$value'</span>)

    <span class="hljs-keyword">var</span> trackByKey = <span class="hljs-keyword">this</span>.params.trackBy
    <span class="hljs-keyword">var</span> oldFrags = <span class="hljs-keyword">this</span>.frags
    <span class="hljs-keyword">var</span> frags = <span class="hljs-keyword">this</span>.frags = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(data.length)
    <span class="hljs-keyword">var</span> alias = <span class="hljs-keyword">this</span>.alias
    <span class="hljs-keyword">var</span> iterator = <span class="hljs-keyword">this</span>.iterator
    <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>.start
    <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.end
    <span class="hljs-keyword">var</span> inDocument = inDoc(start)
    <span class="hljs-keyword">var</span> init = !oldFrags
    <span class="hljs-keyword">var</span> i, l, frag, key, value, primitive

    <span class="hljs-comment">/* First pass, go through the new Array and fill up */</span>
    <span class="hljs-comment">/* the new frags array. If a piece of data has a cached */</span>
    <span class="hljs-comment">/* instance for it, we reuse it. Otherwise build a new */</span>
    <span class="hljs-comment">/* instance. */</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = data.length; i &lt; l; i++) {
      item = data[i]
      key = convertedFromObject ? item.$key : <span class="hljs-literal">null</span>
      value = convertedFromObject ? item.$value : item
      primitive = !isObject(value)
      frag = !init &amp;&amp; <span class="hljs-keyword">this</span>.getCachedFrag(value, i, key)
      <span class="hljs-keyword">if</span> (frag) { <span class="hljs-comment">/* reusable fragment */</span>
        frag.reused = <span class="hljs-literal">true</span>
        <span class="hljs-comment">/* update $index */</span>
        frag.scope.$index = i
        <span class="hljs-comment">/* update $key */</span>
        <span class="hljs-keyword">if</span> (key) {
          frag.scope.$key = key
        }
        <span class="hljs-comment">/* update iterator */</span>
        <span class="hljs-keyword">if</span> (iterator) {
          frag.scope[iterator] = key !== <span class="hljs-literal">null</span> ? key : i
        }
        <span class="hljs-comment">/* update data for track-by, object repeat &amp; */</span>
        <span class="hljs-comment">/* primitive values. */</span>
        <span class="hljs-keyword">if</span> (trackByKey || convertedFromObject || primitive) {
          withoutConversion(() =&gt; {
            frag.scope[alias] = value
          })
        }
      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* new isntance */</span>
        frag = <span class="hljs-keyword">this</span>.create(value, alias, i, key)
        frag.fresh = !init
      }
      frags[i] = frag
      <span class="hljs-keyword">if</span> (init) {
        frag.before(end)
      }
    }

    <span class="hljs-comment">/* we're done for the initial render. */</span>
    <span class="hljs-keyword">if</span> (init) {
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">/* Second pass, go through the old fragments and */</span>
    <span class="hljs-comment">/* destroy those who are not reused (and remove them */</span>
    <span class="hljs-comment">/* from cache) */</span>
    <span class="hljs-keyword">var</span> removalIndex = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> totalRemoved = oldFrags.length - frags.length
    <span class="hljs-comment">/* when removing a large number of fragments, watcher removal */</span>
    <span class="hljs-comment">/* turns out to be a perf bottleneck, so we batch the watcher */</span>
    <span class="hljs-comment">/* removals into a single filter call! */</span>
    <span class="hljs-keyword">this</span>.vm._vForRemoving = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = oldFrags.length; i &lt; l; i++) {
      frag = oldFrags[i]
      <span class="hljs-keyword">if</span> (!frag.reused) {
        <span class="hljs-keyword">this</span>.deleteCachedFrag(frag)
        <span class="hljs-keyword">this</span>.remove(frag, removalIndex++, totalRemoved, inDocument)
      }
    }
    <span class="hljs-keyword">this</span>.vm._vForRemoving = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">if</span> (removalIndex) {
      <span class="hljs-keyword">this</span>.vm._watchers = <span class="hljs-keyword">this</span>.vm._watchers.filter(w =&gt; w.active)
    }

    <span class="hljs-comment">/* Final pass, move/insert new fragments into the */</span>
    <span class="hljs-comment">/* right place. */</span>
    <span class="hljs-keyword">var</span> targetPrev, prevEl, currentPrev
    <span class="hljs-keyword">var</span> insertionIndex = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = frags.length; i &lt; l; i++) {
      frag = frags[i]
      <span class="hljs-comment">/* this is the frag that we should be after */</span>
      targetPrev = frags[i - <span class="hljs-number">1</span>]
      prevEl = targetPrev
        ? targetPrev.staggerCb
          ? targetPrev.staggerAnchor
          : targetPrev.end || targetPrev.node
        : start
      <span class="hljs-keyword">if</span> (frag.reused &amp;&amp; !frag.staggerCb) {
        currentPrev = findPrevFrag(frag, start, <span class="hljs-keyword">this</span>.id)
        <span class="hljs-keyword">if</span> (
          currentPrev !== targetPrev &amp;&amp; (
            !currentPrev ||
            <span class="hljs-comment">/* optimization for moving a single item. */</span>
            <span class="hljs-comment">/* thanks to suggestions by @livoras in #1807 */</span>
            findPrevFrag(currentPrev, start, <span class="hljs-keyword">this</span>.id) !== targetPrev
          )
        ) {
          <span class="hljs-keyword">this</span>.move(frag, prevEl)
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">/* new instance, or still in stagger. */</span>
        <span class="hljs-comment">/* insert with updated stagger index. */</span>
        <span class="hljs-keyword">this</span>.insert(frag, insertionIndex++, prevEl, inDocument)
      }
      frag.reused = frag.fresh = <span class="hljs-literal">false</span>
    }
  },

  <span class="hljs-comment">/**
   * Create a new fragment instance.
   *
   * @param {*} value
   * @param {String} alias
   * @param {Number} index
   * @param {String} [key]
   * @return {Fragment}
   */</span>

  create (value, alias, index, key) {
    <span class="hljs-keyword">var</span> host = <span class="hljs-keyword">this</span>._host
    <span class="hljs-comment">/* create iteration scope */</span>
    <span class="hljs-keyword">var</span> parentScope = <span class="hljs-keyword">this</span>._scope || <span class="hljs-keyword">this</span>.vm
    <span class="hljs-keyword">var</span> scope = <span class="hljs-built_in">Object</span>.create(parentScope)
    <span class="hljs-comment">/* ref holder for the scope */</span>
    scope.$refs = <span class="hljs-built_in">Object</span>.create(parentScope.$refs)
    scope.$els = <span class="hljs-built_in">Object</span>.create(parentScope.$els)
    <span class="hljs-comment">/* make sure point $parent to parent scope */</span>
    scope.$parent = parentScope
    <span class="hljs-comment">/* for two-way binding on alias */</span>
    scope.$forContext = <span class="hljs-keyword">this</span>
    <span class="hljs-comment">/* define scope properties */</span>
    <span class="hljs-comment">/* important: define the scope alias without forced conversion */</span>
    <span class="hljs-comment">/* so that frozen data structures remain non-reactive. */</span>
    withoutConversion(() =&gt; {
      defineReactive(scope, alias, value)
    })
    defineReactive(scope, <span class="hljs-string">'$index'</span>, index)
    <span class="hljs-keyword">if</span> (key) {
      defineReactive(scope, <span class="hljs-string">'$key'</span>, key)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scope.$key) {
      <span class="hljs-comment">/* avoid accidental fallback */</span>
      def(scope, <span class="hljs-string">'$key'</span>, <span class="hljs-literal">null</span>)
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iterator) {
      defineReactive(scope, <span class="hljs-keyword">this</span>.iterator, key !== <span class="hljs-literal">null</span> ? key : index)
    }
    <span class="hljs-keyword">var</span> frag = <span class="hljs-keyword">this</span>.factory.create(host, scope, <span class="hljs-keyword">this</span>._frag)
    frag.forId = <span class="hljs-keyword">this</span>.id
    <span class="hljs-keyword">this</span>.cacheFrag(value, frag, index, key)
    <span class="hljs-keyword">return</span> frag
  },

  <span class="hljs-comment">/**
   * Update the v-ref on owner vm.
   */</span>

  updateRef () {
    <span class="hljs-keyword">var</span> ref = <span class="hljs-keyword">this</span>.descriptor.ref
    <span class="hljs-keyword">if</span> (!ref) <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">var</span> hash = (<span class="hljs-keyword">this</span>._scope || <span class="hljs-keyword">this</span>.vm).$refs
    <span class="hljs-keyword">var</span> refs
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.fromObject) {
      refs = <span class="hljs-keyword">this</span>.frags.map(findVmFromFrag)
    } <span class="hljs-keyword">else</span> {
      refs = {}
      <span class="hljs-keyword">this</span>.frags.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">frag</span>) </span>{
        refs[frag.scope.$key] = findVmFromFrag(frag)
      })
    }
    hash[ref] = refs
  },

  <span class="hljs-comment">/**
   * For option lists, update the containing v-model on
   * parent &lt;select&gt;.
   */</span>

  updateModel () {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOption) {
      <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.start.parentNode
      <span class="hljs-keyword">var</span> model = parent &amp;&amp; parent.__v_model
      <span class="hljs-keyword">if</span> (model) {
        model.forceUpdate()
      }
    }
  },

  <span class="hljs-comment">/**
   * Insert a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Node} prevEl
   * @param {Boolean} inDocument
   */</span>

  insert (frag, index, prevEl, inDocument) {
    <span class="hljs-keyword">if</span> (frag.staggerCb) {
      frag.staggerCb.cancel()
      frag.staggerCb = <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">var</span> staggerAmount = <span class="hljs-keyword">this</span>.getStagger(frag, index, <span class="hljs-literal">null</span>, <span class="hljs-string">'enter'</span>)
    <span class="hljs-keyword">if</span> (inDocument &amp;&amp; staggerAmount) {
      <span class="hljs-comment">/* create an anchor and insert it synchronously, */</span>
      <span class="hljs-comment">/* so that we can resolve the correct order without */</span>
      <span class="hljs-comment">/* worrying about some elements not inserted yet */</span>
      <span class="hljs-keyword">var</span> anchor = frag.staggerAnchor
      <span class="hljs-keyword">if</span> (!anchor) {
        anchor = frag.staggerAnchor = createAnchor(<span class="hljs-string">'stagger-anchor'</span>)
        anchor.__v_frag = frag
      }
      after(anchor, prevEl)
      <span class="hljs-keyword">var</span> op = frag.staggerCb = cancellable(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        frag.staggerCb = <span class="hljs-literal">null</span>
        frag.before(anchor)
        remove(anchor)
      })
      setTimeout(op, staggerAmount)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> target = prevEl.nextSibling
      <span class="hljs-comment">/* istanbul ignore if */</span>
      <span class="hljs-keyword">if</span> (!target) {
        <span class="hljs-comment">/* reset end anchor position in case the position was messed up */</span>
        <span class="hljs-comment">/* by an external drag-n-drop library. */</span>
        after(<span class="hljs-keyword">this</span>.end, prevEl)
        target = <span class="hljs-keyword">this</span>.end
      }
      frag.before(target)
    }
  },

  <span class="hljs-comment">/**
   * Remove a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {Boolean} inDocument
   */</span>

  remove (frag, index, total, inDocument) {
    <span class="hljs-keyword">if</span> (frag.staggerCb) {
      frag.staggerCb.cancel()
      frag.staggerCb = <span class="hljs-literal">null</span>
      <span class="hljs-comment">/* it's not possible for the same frag to be removed */</span>
      <span class="hljs-comment">/* twice, so if we have a pending stagger callback, */</span>
      <span class="hljs-comment">/* it means this frag is queued for enter but removed */</span>
      <span class="hljs-comment">/* before its transition started. Since it is already */</span>
      <span class="hljs-comment">/* destroyed, we can just leave it in detached state. */</span>
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">var</span> staggerAmount = <span class="hljs-keyword">this</span>.getStagger(frag, index, total, <span class="hljs-string">'leave'</span>)
    <span class="hljs-keyword">if</span> (inDocument &amp;&amp; staggerAmount) {
      <span class="hljs-keyword">var</span> op = frag.staggerCb = cancellable(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        frag.staggerCb = <span class="hljs-literal">null</span>
        frag.remove()
      })
      setTimeout(op, staggerAmount)
    } <span class="hljs-keyword">else</span> {
      frag.remove()
    }
  },

  <span class="hljs-comment">/**
   * Move a fragment to a new position.
   * Force no transition.
   *
   * @param {Fragment} frag
   * @param {Node} prevEl
   */</span>

  move (frag, prevEl) {
    <span class="hljs-comment">/* fix a common issue with Sortable: */</span>
    <span class="hljs-comment">/* if prevEl doesn't have nextSibling, this means it's */</span>
    <span class="hljs-comment">/* been dragged after the end anchor. Just re-position */</span>
    <span class="hljs-comment">/* the end anchor to the end of the container. */</span>
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (!prevEl.nextSibling) {
      <span class="hljs-keyword">this</span>.end.parentNode.appendChild(<span class="hljs-keyword">this</span>.end)
    }
    frag.before(prevEl.nextSibling, <span class="hljs-literal">false</span>)
  },

  <span class="hljs-comment">/**
   * Cache a fragment using track-by or the object key.
   *
   * @param {*} value
   * @param {Fragment} frag
   * @param {Number} index
   * @param {String} [key]
   */</span>

  cacheFrag (value, frag, index, key) {
    <span class="hljs-keyword">var</span> trackByKey = <span class="hljs-keyword">this</span>.params.trackBy
    <span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">this</span>.cache
    <span class="hljs-keyword">var</span> primitive = !isObject(value)
    <span class="hljs-keyword">var</span> id
    <span class="hljs-keyword">if</span> (key || trackByKey || primitive) {
      id = getTrackByKey(index, key, value, trackByKey)
      <span class="hljs-keyword">if</span> (!cache[id]) {
        cache[id] = frag
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trackByKey !== <span class="hljs-string">'$index'</span>) {
        process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;
        <span class="hljs-keyword">this</span>.warnDuplicate(value)
      }
    } <span class="hljs-keyword">else</span> {
      id = <span class="hljs-keyword">this</span>.id
      <span class="hljs-keyword">if</span> (hasOwn(value, id)) {
        <span class="hljs-keyword">if</span> (value[id] === <span class="hljs-literal">null</span>) {
          value[id] = frag
        } <span class="hljs-keyword">else</span> {
          process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;
          <span class="hljs-keyword">this</span>.warnDuplicate(value)
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.isExtensible(value)) {
        def(value, id, frag)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) {
        warn(
          <span class="hljs-string">'Frozen v-for objects cannot be automatically tracked, make sure to '</span> +
          <span class="hljs-string">'provide a track-by key.'</span>
        )
      }
    }
    frag.raw = value
  },

  <span class="hljs-comment">/**
   * Get a cached fragment from the value/index/key
   *
   * @param {*} value
   * @param {Number} index
   * @param {String} key
   * @return {Fragment}
   */</span>

  getCachedFrag (value, index, key) {
    <span class="hljs-keyword">var</span> trackByKey = <span class="hljs-keyword">this</span>.params.trackBy
    <span class="hljs-keyword">var</span> primitive = !isObject(value)
    <span class="hljs-keyword">var</span> frag
    <span class="hljs-keyword">if</span> (key || trackByKey || primitive) {
      <span class="hljs-keyword">var</span> id = getTrackByKey(index, key, value, trackByKey)
      frag = <span class="hljs-keyword">this</span>.cache[id]
    } <span class="hljs-keyword">else</span> {
      frag = value[<span class="hljs-keyword">this</span>.id]
    }
    <span class="hljs-keyword">if</span> (frag &amp;&amp; (frag.reused || frag.fresh)) {
      process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;
      <span class="hljs-keyword">this</span>.warnDuplicate(value)
    }
    <span class="hljs-keyword">return</span> frag
  },

  <span class="hljs-comment">/**
   * Delete a fragment from cache.
   *
   * @param {Fragment} frag
   */</span>

  deleteCachedFrag (frag) {
    <span class="hljs-keyword">var</span> value = frag.raw
    <span class="hljs-keyword">var</span> trackByKey = <span class="hljs-keyword">this</span>.params.trackBy
    <span class="hljs-keyword">var</span> scope = frag.scope
    <span class="hljs-keyword">var</span> index = scope.$index
    <span class="hljs-comment">/* fix #948: avoid accidentally fall through to */</span>
    <span class="hljs-comment">/* a parent repeater which happens to have $key. */</span>
    <span class="hljs-keyword">var</span> key = hasOwn(scope, <span class="hljs-string">'$key'</span>) &amp;&amp; scope.$key
    <span class="hljs-keyword">var</span> primitive = !isObject(value)
    <span class="hljs-keyword">if</span> (trackByKey || key || primitive) {
      <span class="hljs-keyword">var</span> id = getTrackByKey(index, key, value, trackByKey)
      <span class="hljs-keyword">this</span>.cache[id] = <span class="hljs-literal">null</span>
    } <span class="hljs-keyword">else</span> {
      value[<span class="hljs-keyword">this</span>.id] = <span class="hljs-literal">null</span>
      frag.raw = <span class="hljs-literal">null</span>
    }
  },

  <span class="hljs-comment">/**
   * Get the stagger amount for an insertion/removal.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {String} type
   */</span>

  getStagger (frag, index, total, type) {
    type = type + <span class="hljs-string">'Stagger'</span>
    <span class="hljs-keyword">var</span> trans = frag.node.__v_trans
    <span class="hljs-keyword">var</span> hooks = trans &amp;&amp; trans.hooks
    <span class="hljs-keyword">var</span> hook = hooks &amp;&amp; (hooks[type] || hooks.stagger)
    <span class="hljs-keyword">return</span> hook
      ? hook.call(frag, index, total)
      : index * <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.params[type] || <span class="hljs-keyword">this</span>.params.stagger, <span class="hljs-number">10</span>)
  },

  <span class="hljs-comment">/**
   * Pre-process the value before piping it through the
   * filters. This is passed to and called by the watcher.
   */</span>

  _preProcess (value) {
    <span class="hljs-comment">/* regardless of type, store the un-filtered raw value. */</span>
    <span class="hljs-keyword">this</span>.rawValue = value
    <span class="hljs-keyword">return</span> value
  },

  <span class="hljs-comment">/**
   * Post-process the value after it has been piped through
   * the filters. This is passed to and called by the watcher.
   *
   * It is necessary for this to be called during the
   * watcher's dependency collection phase because we want
   * the v-for to update when the source Object is mutated.
   */</span>

  _postProcess (value) {
    <span class="hljs-keyword">if</span> (isArray(value)) {
      <span class="hljs-keyword">return</span> value
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPlainObject(value)) {
      <span class="hljs-comment">/* convert plain object to array. */</span>
      <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(value)
      <span class="hljs-keyword">var</span> i = keys.length
      <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(i)
      <span class="hljs-keyword">var</span> key
      <span class="hljs-keyword">while</span> (i--) {
        key = keys[i]
        res[i] = {
          $key: key,
          $value: value[key]
        }
      }
      <span class="hljs-keyword">return</span> res
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(value)) {
        value = range(value)
      }
      <span class="hljs-keyword">return</span> value || []
    }
  },

  unbind () {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.descriptor.ref) {
      (<span class="hljs-keyword">this</span>._scope || <span class="hljs-keyword">this</span>.vm).$refs[<span class="hljs-keyword">this</span>.descriptor.ref] = <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frags) {
      <span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>.frags.length
      <span class="hljs-keyword">var</span> frag
      <span class="hljs-keyword">while</span> (i--) {
        frag = <span class="hljs-keyword">this</span>.frags[i]
        <span class="hljs-keyword">this</span>.deleteCachedFrag(frag)
        frag.destroy()
      }
    }
  }
}

<span class="hljs-comment">/**
 * Helper to find the previous element that is a fragment
 * anchor. This is necessary because a destroyed frag's
 * element could still be lingering in the DOM before its
 * leaving transition finishes, but its inserted flag
 * should have been set to false so we can skip them.
 *
 * If this is a block repeat, we want to make sure we only
 * return frag that is bound to this v-for. (see #929)
 *
 * @param {Fragment} frag
 * @param {Comment|Text} anchor
 * @param {String} id
 * @return {Fragment}
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPrevFrag</span> (<span class="hljs-params">frag, anchor, id</span>) </span>{
  <span class="hljs-keyword">var</span> el = frag.node.previousSibling
  <span class="hljs-comment">/* istanbul ignore if */</span>
  <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">return</span>
  frag = el.__v_frag
  <span class="hljs-keyword">while</span> (
    (!frag || frag.forId !== id || !frag.inserted) &amp;&amp;
    el !== anchor
  ) {
    el = el.previousSibling
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (!el) <span class="hljs-keyword">return</span>
    frag = el.__v_frag
  }
  <span class="hljs-keyword">return</span> frag
}

<span class="hljs-comment">/**
 * Create a range array from given number.
 *
 * @param {Number} n
 * @return {Array}
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span> (<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">-1</span>
  <span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">Math</span>.floor(n))
  <span class="hljs-keyword">while</span> (++i &lt; n) {
    ret[i] = i
  }
  <span class="hljs-keyword">return</span> ret
}

<span class="hljs-comment">/**
 * Get the track by key for an item.
 *
 * @param {Number} index
 * @param {String} key
 * @param {*} value
 * @param {String} [trackByKey]
 */</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTrackByKey</span> (<span class="hljs-params">index, key, value, trackByKey</span>) </span>{
  <span class="hljs-keyword">return</span> trackByKey
    ? trackByKey === <span class="hljs-string">'$index'</span>
      ? index
      : trackByKey.charAt(<span class="hljs-number">0</span>).match(<span class="hljs-regexp">/\w/</span>)
        ? getPath(value, trackByKey)
        : value[trackByKey]
    : (key || value)
}

<span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) {
  vFor.warnDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    warn(
      <span class="hljs-string">'Duplicate value found in v-for="'</span> + <span class="hljs-keyword">this</span>.descriptor.raw + <span class="hljs-string">'": '</span> +
      <span class="hljs-built_in">JSON</span>.stringify(value) + <span class="hljs-string">'. Use track-by="$index" if '</span> +
      <span class="hljs-string">'you are expecting duplicate values.'</span>,
      <span class="hljs-keyword">this</span>.vm
    )
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> vFor</pre></div>
            </div>
        </li>
        
    </ul>
</section>
</body>
</html>
